---
title: "Nonlinear Dynamic eQTL analysis on iPSC"
author: "Ziang Zhang"
date: "2025-02-21"
output: 
  workflowr::wflow_html:
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(fig.width = 8, fig.height = 6)
library(fashr)
library(biomaRt)
mart <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
result_dir <- paste0(getwd(), "/output/dynamic_eQTL_real")
data_dir <- paste0(getwd(), "/data/dynamic_eQTL_real")
code_dir <- paste0(getwd(), "/code/dynamic_eQTL_real")
log_prec <- seq(0,10, by = 0.2)
fine_grid <- sort(c(0, exp(-0.5*log_prec)))
```

## Obtain the effect size of eQTLs

We use the processed (expression \& genotype) data of [Strober et.al, 2019](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6623972/) to perform the eQTL analysis.

For the association testing, we use a linear regression model for each gene-variant pair at each time point.
Following the practice in Strober et.al, we adjust for the first 3 PCs.

The code to perform this step can be found in the script `dynamic_eQTL_real/00_eQTLs.R` from the code directory.

After this step, we have the effect size of eQTLs for each gene-variant pair at each time point, as well as its standard error.



## Fitting FASH

To fit the FASH model on $\{\beta_i(t_j), s_{ij}\}_{i\in N,j \in [16]}$, we consider fitting two FASH models:

- A FASH model based on first order IWP (testing for dynamic eQTLs: $H_0: \beta_i(t)=c$).

- A FASH model based on second order IWP (testing for nonlinear-dynamic eQTLs: $H_0: \beta_i(t)=c_1+c_2t$).

The code to perform this step can be found in the script `dynamic_eQTL_real/01_fash.R` from the code directory.

We will directly load the fitted FASH models from the output directory.

```{r helpers, echo=FALSE}
# ------------------------------------------------------------
# Helpers (used throughout; keep plots consistent & reduce bugs)
# ------------------------------------------------------------

fmt_sci <- function(x, digits = 2) {
  if (is.na(x)) return("NA")
  formatC(x, format = "e", digits = digits)
}

sample_int <- function(n, size, seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  if (n <= 0) return(integer(0))
  sample.int(n, size = min(size, n))
}

parse_pair_key <- function(keys) {
  parts <- strsplit(keys, "_", fixed = TRUE)
  ens_id <- vapply(parts, `[[`, character(1), 1)
  rs_id  <- vapply(parts, `[[`, character(1), 2)
  tibble(key = keys, ens_id = ens_id, rs_id = rs_id)
}

symbol_of <- function(ens_id, gene_map) {
  if (is.null(gene_map)) return(ens_id)
  if (!all(c("ensembl_gene_id", "hgnc_symbol") %in% names(gene_map))) return(ens_id)
  sym <- gene_map$hgnc_symbol[match(ens_id, gene_map$ensembl_gene_id)]
  ifelse(is.na(sym) | sym == "", ens_id, sym)
}

# ------------------------------------------------------------
# Plotting for nonlinear fits (match the "dynamic_eQTL_real" style)
# - show gene symbol + variant id in title
# - show pointwise credible interval band from predict()
# - show +/- 2*SE error bars
# - (optional) show weighted linear/quadratic fits
# - captions: by default show lfdr(raw/adj); for classification, can show lfsr only
# ------------------------------------------------------------
plot_pair_nonlinear_base <- function(idx,
                                     datasets,
                                     fash_raw,
                                     fash_adj,
                                     gene_map = NULL,
                                     smooth_var = seq(0, 15, by = 0.1),
                                     add_lm = TRUE,
                                     add_quad = TRUE,
                                     main_prefix = NULL,
                                     subtitle_override = NULL,
                                     lfsr_map = NULL) {
  dat <- datasets[[idx]]
  x  <- dat$x
  y  <- dat$y
  se <- dat$SE
  w  <- 1 / (se^2)

  key <- names(datasets)[idx]
  key_parts <- strsplit(key, "_", fixed = TRUE)[[1]]
  ens_id <- key_parts[1]
  rs_id  <- key_parts[2]
  gsym   <- symbol_of(ens_id, gene_map)

  main_txt <- paste0(gsym, ": ", rs_id)
  if (!is.null(main_prefix)) main_txt <- paste0(main_prefix, " ", main_txt)

  fitted <- predict(fash_adj, index = idx, smooth_var = smooth_var)

  y_min <- min(y - 2 * se, fitted$lower, na.rm = TRUE)
  y_max <- max(y + 2 * se, fitted$upper, na.rm = TRUE)

  # fits for reference (same as before, but optional)
  lin_fit  <- if (add_lm)   lm(y ~ x, weights = w) else NULL
  quad_fit <- if (add_quad) lm(y ~ poly(x, 2, raw = TRUE), weights = w) else NULL
  x_grid   <- if (add_quad) seq(min(x), max(x), length.out = 200) else NULL
  quad_pred <- if (add_quad) predict(quad_fit, newdata = data.frame(x = x_grid)) else NULL

  plot(x, y, pch = 20, col = "black",
       xlab = "Time", ylab = "Effect Est",
       ylim = c(y_min, y_max))
  title(main = main_txt)

  # +/- 2*SE bars
  arrows(x0 = x, y0 = y - 2 * se, x1 = x, y1 = y + 2 * se,
         length = 0.05, angle = 90, code = 3, col = "black")

  # credible interval band
  polygon(c(fitted$x, rev(fitted$x)), c(fitted$lower, rev(fitted$upper)),
          col = rgb(1, 0, 0, 0.1), border = NA)
  lines(fitted$x, fitted$mean, col = "red", lwd = 2)

  if (add_lm)   abline(lin_fit, col = "green", lty = 2, lwd = 1)
  if (add_quad) lines(x_grid, quad_pred, col = "purple", lty = 2, lwd = 1)

  # caption control
  if (!is.null(subtitle_override)) {
    cap <- subtitle_override
  } else if (!is.null(lfsr_map)) {
    lfsr_val <- unname(lfsr_map[as.character(idx)])
    cap <- paste0("lfsr (adj) = ", fmt_sci(lfsr_val))
  } else {
    lfdr_before <- fash_raw$lfdr[idx]
    lfdr_after  <- fash_adj$lfdr[idx]
    cap <- paste0("lfdr (adj/raw) = ", fmt_sci(lfdr_after), " / ", fmt_sci(lfdr_before))
  }

  title(sub = cap, cex.sub = 0.8)
  invisible(NULL)
}

plot_many_pairs_nonlinear <- function(idxs, nrow = 2, ncol = 2, ...) {
  oldpar <- par(no.readonly = TRUE)
  on.exit(par(oldpar), add = TRUE)
  par(mfrow = c(nrow, ncol))
  for (idx in idxs) plot_pair_nonlinear_base(idx = idx, ...)
  invisible(NULL)
}

# For early/middle/late/switch classification examples: show lfsr only (and keep the plot clean)
plot_many_pairs_nonlinear_lfsr <- function(idxs, testing_obj, nrow = 2, ncol = 2, ...) {
  lfsr_map <- setNames(testing_obj$lfsr, testing_obj$indices)
  oldpar <- par(no.readonly = TRUE)
  on.exit(par(oldpar), add = TRUE)
  par(mfrow = c(nrow, ncol))
  for (idx in idxs) plot_pair_nonlinear_base(idx = idx, lfsr_map = lfsr_map, ...)
  invisible(NULL)
}
```

```{r}
load(paste0(result_dir, "/fash_fit2_all.RData"))
```

We will load the datasets from the fitted FASH object:

```{r}
datasets <- fash_fit2$fash_data$data_list
for (i in 1:length(datasets)) {
  datasets[[i]]$SE <- fash_fit2$fash_data$S[[i]]
}
all_genes <- unique(sapply(strsplit(names(datasets), "_"), "[[", 1))

full_map <- getBM(
  attributes = c("hgnc_symbol", "ensembl_gene_id"),
  filters    = "ensembl_gene_id",
  values     = all_genes,
  mart       = mart
)
```


In this analysis, we will focus on the **FASH(2)** model that assumes a **second order IWP** and tests for **nonlinear dynamic eQTLs**.

Let's take a quick overview of the fitted FASH model:

```{r, eval=FALSE}
log_prec <- seq(0,10, by = 0.2)
fine_grid <- sort(c(0, exp(-0.5*log_prec)))

fash_fit2 <- fash(Y = "beta", smooth_var = "time", S = "SE", data_list = datasets,
                  num_basis = 20, order = 2, betaprec = 0,
                  pred_step = 1, penalty = 10, grid = fine_grid,
                  num_cores = num_cores, verbose = TRUE)
save(fash_fit2, file = "./results/fash_fit2_all.RData")
```


```{r}
fash_fit2
```

As well as the estimated priors:
```{r}
fash_fit2$prior_weights
```

## Problem with $\pi_0$ estimation

The original MLE estimated $\pi_0$ is `r fash_fit2$prior_weights$prior_weight[1]`.
This could be under-estimated due to model-misspecification under the alternative hypothesis.
To account for this, we will a conservative estimate of $\pi_0$ based on the BF procedure:

```{r eval=FALSE}
fash_fit2_update <- BF_update(fash_fit2, plot = FALSE)
fash_fit2_update$prior_weights
save(fash_fit2_update, file = paste0(result_dir, "/fash_fit2_update.RData"))
```

```{r echo=FALSE}
load(paste0(result_dir, "/fash_fit2_update.RData"))
```

The conservative estimate is `r fash_fit2_update$prior_weights$prior_weight[1]`, which is much more conservative.


## Detecting Nonlinear dynamic eQTLs

We will use the updated FASH model (2) to detect nonlinear dynamic eQTLs.

```{r}
alpha <- 0.05
test2 <- fdr_control(fash_fit2_update, alpha = alpha, plot = F)
fash_highlighted2 <- test2$fdr_results$index[test2$fdr_results$FDR <= alpha]

test2_before <- fdr_control(fash_fit2, alpha = alpha, plot = F)
fash_highlighted2_before <- test2_before$fdr_results$index[test2_before$fdr_results$FDR <= alpha]
```

How many pairs are detected?

```{r}
pairs_highlighted2 <- names(datasets)[fash_highlighted2]
length(pairs_highlighted2)
length(pairs_highlighted2)/length(datasets)
```


What is the number before the BF adjustment?

```{r}
pairs_highlighted2_before <- names(datasets)[fash_highlighted2_before]
length(pairs_highlighted2_before)
length(pairs_highlighted2_before)/length(datasets)
```


How many unique genes are detected?

```{r}
genes_highlighted2 <- unique(sapply(strsplit(pairs_highlighted2, "_"), "[[", 1))
length(genes_highlighted2)
length(genes_highlighted2)/length(all_genes)
```

Before the BF adjustment?

```{r}
genes_highlighted2_before <- unique(sapply(strsplit(pairs_highlighted2_before, "_"), "[[", 1))
length(genes_highlighted2_before)
length(genes_highlighted2_before)/length(all_genes)
```


Visualize top-ranked pairs:

```{r nonlinear_dynamic_examples, echo=FALSE}
genes_highlighted2_subset <- c("AMN", "RIPK2", "LPAR2", "ST6GALNAC2")

# convert symbols to ensembl IDs
map <- getBM(
  attributes = c("hgnc_symbol", "ensembl_gene_id"),
  filters    = "hgnc_symbol",
  values     = genes_highlighted2_subset,
  mart       = mart
)
genes_highlighted2_subset_ens <- map$ensembl_gene_id[match(genes_highlighted2_subset, map$hgnc_symbol)]

par(mfrow = c(2, 2))
for (i in seq_along(genes_highlighted2_subset_ens)) {
  selected_gene <- genes_highlighted2_subset_ens[i]

  # restrict to highlighted pairs for this gene
  pairs_of_selected_gene <- grep(selected_gene, pairs_highlighted2, value = TRUE)
  selected_indices <- which(names(datasets) %in% pairs_of_selected_gene)
  if (length(selected_indices) == 0) next

  # pick the most significant (min adjusted lfdr)
  lfdr_adj_vec <- fash_fit2_update$lfdr[selected_indices]
  selected_index <- selected_indices[which.min(lfdr_adj_vec)]

  plot_pair_nonlinear_base(
    idx = selected_index,
    datasets = datasets,
    fash_raw = fash_fit2,
    fash_adj = fash_fit2_update,
    gene_map = full_map
  )
}
par(mfrow = c(1, 1))
```


Some examples of null pairs:

```{r nonlinear_null_examples, echo=FALSE}
genes_not_highlighted2 <- setdiff(all_genes, genes_highlighted2)
pairs_not_highlighted2 <- setdiff(names(datasets), pairs_highlighted2)

par(mfrow = c(2, 2))
for (i in 10:13) {
  if (i > length(genes_not_highlighted2)) next
  selected_gene <- genes_not_highlighted2[i]
  pairs_of_selected_gene <- grep(selected_gene, pairs_not_highlighted2, value = TRUE)
  selected_indices <- which(names(datasets) %in% pairs_of_selected_gene)
  if (length(selected_indices) == 0) next

  # pick a representative pair: smallest adjusted lfdr
  lfdr_adj_vec <- fash_fit2_update$lfdr[selected_indices]
  selected_index <- selected_indices[which.min(lfdr_adj_vec)]

  plot_pair_nonlinear_base(
    idx = selected_index,
    datasets = datasets,
    fash_raw = fash_fit2,
    fash_adj = fash_fit2_update,
    gene_map = full_map
  )
}
par(mfrow = c(1, 1))
```



## Comparing with Strober et.al

We will compare the detected dynamic eQTLs with the results from Strober et.al.

```{r echo=FALSE}
library(ggVennDiagram)
library(tidyverse)
strober_nonlinear <- read.delim(paste0(data_dir, "/strober_nonlinear/non_linear_dynamic_eqtls_5_pc.txt"))
strober_nonlinear$key <- paste0(strober_nonlinear$ensamble_id, "_", strober_nonlinear$rs_id)
strober_nonlinear_highlighted <- strober_nonlinear %>% filter(eFDR <= alpha)
pairs_highlighted_strober_nonlinear <- strober_nonlinear_highlighted$key
genes_highlighted_strober_nonlinear <- unique(sapply(strsplit(pairs_highlighted_strober_nonlinear, "_"), "[[", 1))
strober_linear <- read.delim(paste0(data_dir, "/strober_linear/linear_dynamic_eqtls_5_pc.txt"))
strober_linear$key <- paste0(strober_linear$ensamble_id, "_", strober_linear$rs_id)
strober_linear_highlighted <- strober_linear %>% filter(eFDR <= alpha)
pairs_highlighted_strober_linear <- strober_linear_highlighted$key
genes_highlighted_strober_linear <- unique(sapply(strsplit(pairs_highlighted_strober_linear, "_"), "[[", 1))
```

Let's take a look at the 4 pairs that are least significant from FASH:

```{r only_fash_least, echo=FALSE}
gene_fashr_only <- setdiff(genes_highlighted2, union(genes_highlighted_strober_nonlinear, genes_highlighted_strober_linear))

par(mfrow = c(2, 2))
for (i in 1:min(4, length(gene_fashr_only))) {
  selected_gene <- gene_fashr_only[i]
  pairs_of_selected_gene <- grep(selected_gene, pairs_highlighted2, value = TRUE)
  selected_indices <- which(names(datasets) %in% pairs_of_selected_gene)
  if (length(selected_indices) == 0) next

  # pick a "least significant" one among highlighted: max adjusted lfdr (keep original intent)
  lfdr_adj_vec <- fash_fit2_update$lfdr[selected_indices]
  selected_index <- selected_indices[which.max(lfdr_adj_vec)]

  plot_pair_nonlinear_base(
    idx = selected_index,
    datasets = datasets,
    fash_raw = fash_fit2,
    fash_adj = fash_fit2_update,
    gene_map = full_map
  )
}
par(mfrow = c(1, 1))
```

Let's also look at the genes that were missed by FASH, but detected by Strober et.al.
In this case, we will pick the most significant pair for each gene in FASH:

```{r miss_fash_most, echo=FALSE}
gene_missed <- setdiff(union(genes_highlighted_strober_nonlinear, genes_highlighted_strober_linear), genes_highlighted2)

par(mfrow = c(2, 2))
for (i in 1:min(4, length(gene_missed))) {
  selected_gene <- gene_missed[i]
  pairs_of_selected_gene <- grep(selected_gene, names(datasets), value = TRUE)
  selected_indices <- which(names(datasets) %in% pairs_of_selected_gene)
  if (length(selected_indices) == 0) next

  # pick the most significant pair for that gene under the fitted model: min adjusted lfdr
  lfdr_adj_vec <- fash_fit2_update$lfdr[selected_indices]
  selected_index <- selected_indices[which.min(lfdr_adj_vec)]

  plot_pair_nonlinear_base(
    idx = selected_index,
    datasets = datasets,
    fash_raw = fash_fit2,
    fash_adj = fash_fit2_update,
    gene_map = full_map
  )
}
par(mfrow = c(1, 1))
```


## Classifying nonlinear dynamic eQTLs

Following the definition in Strober et.al, we will classify the detected eQTLs into different categories:

- *Early*: eQTLs with strongest effect during the first three days: $\max_{t\leq3} |\beta(t)| - \max_{t> 3} |\beta(t)| > 0$.

- *Late*: eQTLs with strongest effect during the last four days: $\max_{t\geq 12} |\beta(t)| - \max_{t< 12} |\beta(t)| > 0$.

- *Middle*: eQTLs with strongest effect during days 4-11: $\max_{4\leq t\leq 11} |\beta(t)| - \max_{t> 11 | t< 4} |\beta(t)| > 0$.

- *Switch*: eQTLs with effect sign switch during the time course: $\min\{\max\beta(t)^+,\max\beta(t)^-\}-c $ where $c$ is a threshold that we set to 0.25 (which means with two alleles, the maximal difference of effect size is at least $\geq 2\times\min\{\max\beta(t)^+,\max\beta(t)^-\}\times2 \geq  2 \times 0.25  \times 2 = 1$).

We first take a look at the significant pairs detected by FASH (order 2), and classify them based on the false sign rate (lfsr):

```{r eval=FALSE}
smooth_var_refined = seq(0,15, by = 0.1)
functional_early <- function(x){
  max(abs(x[smooth_var_refined <= 3])) - max(abs(x[smooth_var_refined > 3]))
}
testing_early_nonlin_dyn <- testing_functional(functional_early,
                                              lfsr_cal = function(x){mean(x <= 0)},
                                              fash = fash_fit2,
                                              indices = fash_highlighted2,
                                              smooth_var = smooth_var_refined)
```

How many pairs and how many unique genes are classified as early dynamic eQTLs?

```{r}
load(paste0(result_dir, "/classify_nonlin_dyn_eQTLs_early.RData"))
early_indices <- testing_early_nonlin_dyn$indices[testing_early_nonlin_dyn$cfsr <= alpha]
length(early_indices)
early_genes <- unique(sapply(strsplit(names(datasets)[early_indices], "_"), "[[", 1))
length(early_genes)
```

How many pairs are classified as middle dynamic eQTLs?

```{r eval=FALSE}
functional_middle <- function(x){
  max(abs(x[smooth_var_refined <= 11 & smooth_var_refined >= 4])) - max(abs(x[smooth_var_refined > 11]), abs(x[smooth_var_refined < 4]))
}
testing_middle_nonlin_dyn <- testing_functional(functional_middle, 
                                               lfsr_cal = function(x){mean(x <= 0)},
                                               fash = fash_fit2, 
                                               indices = fash_highlighted2, 
                                               num_cores = num_cores,
                                               smooth_var = smooth_var_refined)
```


```{r}
load(paste0(result_dir, "/classify_nonlin_dyn_eQTLs_middle.RData"))
middle_indices <- testing_middle_nonlin_dyn$indices[testing_middle_nonlin_dyn$cfsr <= alpha]
length(middle_indices)
middle_genes <- unique(sapply(strsplit(names(datasets)[middle_indices], "_"), "[[", 1))
length(middle_genes)
```

Take a look at their results:

```{r middle_examples, echo=FALSE}
idxs_middle <- middle_indices[sample_int(length(middle_indices), 4, seed = 2)]

plot_many_pairs_nonlinear_lfsr(
  idxs_middle,
  testing_obj = testing_middle_nonlin_dyn,
  datasets = datasets,
  fash_raw = fash_fit2,
  fash_adj = fash_fit2_update,
  gene_map = full_map
)
```


How many pairs are classified as late dynamic eQTLs?

```{r eval=FALSE}
functional_late <- function(x){
  max(abs(x[smooth_var_refined >= 12])) - max(abs(x[smooth_var_refined < 12]))
}
testing_late_nonlin_dyn <- testing_functional(functional_late, 
                                             lfsr_cal = function(x){mean(x <= 0)},
                                             fash = fash_fit2, 
                                             indices = fash_highlighted2, 
                                             num_cores = num_cores,
                                             smooth_var = smooth_var_refined)
```

```{r}
load(paste0(result_dir, "/classify_nonlin_dyn_eQTLs_late.RData"))
late_indices <- testing_late_nonlin_dyn$indices[testing_late_nonlin_dyn$cfsr <= alpha]
length(late_indices)
late_genes <- unique(sapply(strsplit(names(datasets)[late_indices], "_"), "[[", 1))
length(late_genes)
```

Let's take a look at the top-ranked late dynamic eQTLs:

```{r late_examples, echo=FALSE}
idxs_late <- head(late_indices, 4)

plot_many_pairs_nonlinear_lfsr(
  idxs_late,
  testing_obj = testing_late_nonlin_dyn,
  datasets = datasets,
  fash_raw = fash_fit2,
  fash_adj = fash_fit2_update,
  gene_map = full_map
)
```

How many pairs and how many unique genes are classified as switch dynamic eQTLs?

```{r eval=FALSE}
switch_threshold <- 0.25
functional_switch <- function(x){
  # compute the radius of x, measured by deviation from 0 from below and from above
  x_pos <- x[x > 0]
  x_neg <- x[x < 0]
  if(length(x_pos) == 0 || length(x_neg) == 0){
    return(0)
  }
  min(max(abs(x_pos)), max(abs(x_neg))) - switch_threshold
}
testing_switch_nonlin_dyn <- testing_functional(functional_switch, 
                                               lfsr_cal = function(x){mean(x <= 0)},
                                               fash = fash_fit2, 
                                               indices = fash_highlighted2, 
                                               num_cores = num_cores,
                                               smooth_var = smooth_var_refined)
```

```{r}
load(paste0(result_dir, "/classify_nonlin_dyn_eQTLs_switch.RData"))
switch_indices <- testing_switch_nonlin_dyn$indices[testing_switch_nonlin_dyn$cfsr <= alpha]
length(switch_indices)
switch_genes <- unique(sapply(strsplit(names(datasets)[switch_indices], "_"), "[[", 1))
length(switch_genes)
```

Let's take a look at the top-ranked switch dynamic eQTLs:

```{r switch_examples, echo=FALSE}
# pick the top 4 switch indices (already filtered by cfsr)
idxs_sw <- head(switch_indices, 4)

plot_many_pairs_nonlinear_lfsr(
  idxs_sw,
  testing_obj = testing_switch_nonlin_dyn,
  datasets = datasets,
  fash_raw = fash_fit2,
  fash_adj = fash_fit2_update,
  gene_map = full_map
)
```



## Gene Set Enrichment Analysis

```{r warning=FALSE, message=FALSE}
library(clusterProfiler)
library(tidyverse)
library(msigdbr)
library(org.Hs.eg.db)  # Assuming human genes
library(biomaRt)
library(cowplot)
# Retrieve Hallmark gene sets for Homo sapiens
m_t2g <- msigdbr(species = "Homo sapiens", category = "H") %>% 
  dplyr::select(gs_name, entrez_gene)
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

## A function to check gene-enrichment
## Retrieve Hallmark gene sets for Homo sapiens (use Ensembl IDs)
m_t2g <- msigdbr(species = "Homo sapiens", category = "H") %>% 
  mutate(ensembl_use = dplyr::coalesce(ensembl_gene, db_ensembl_gene)) %>% 
  dplyr::filter(!is.na(ensembl_use)) %>% 
  dplyr::select(gs_name, ensembl_use) %>%
  dplyr::distinct()    # one row per (pathway, Ensembl) pair


## A function to check gene-enrichment using Ensembl IDs,
## forcing the universe to be exactly background_gene
enrich_set <- function(genes_selected,
                       background_gene,
                       q_val_cutoff = 0.05,
                       pvalueCutoff = 0.05) {

  # ensure character vectors & unique
  genes_selected_raw  <- unique(as.character(genes_selected))
  background_gene_raw <- unique(as.character(background_gene))

  # we'll enforce that the test universe is exactly these:
  universe_for_test <- background_gene_raw

  # genes that are in Hallmark already
  hallmark_genes <- unique(m_t2g$ensembl_use)

  # background genes that are NOT in Hallmark (no annotation)
  bg_not_in_hallmark <- setdiff(universe_for_test, hallmark_genes)

  # extend TERM2GENE so that *all* background genes appear in it at least once
  # add them to a dummy pathway that we will later drop
  dummy_id <- "__DUMMY_BACKGROUND__"

  if (length(bg_not_in_hallmark) > 0) {
    dummy_t2g <- tibble(
      gs_name     = dummy_id,
      ensembl_use = bg_not_in_hallmark
    )
    TERM2GENE_full <- bind_rows(m_t2g, dummy_t2g)
  } else {
    TERM2GENE_full <- m_t2g
  }

  # also make sure selected genes are a subset of the universe
  genes_sel_used <- intersect(genes_selected_raw, universe_for_test)

  # message("Original selected genes: ", length(genes_selected_raw),
  #         " ; used in enrichment: ", length(genes_sel_used))
  # message("Universe size (background_gene): ", length(universe_for_test))

  enrich_res <- enricher(
    gene          = genes_sel_used,
    TERM2GENE     = TERM2GENE_full,
    universe      = universe_for_test,
    pAdjustMethod = "BH",
    qvalueCutoff  = q_val_cutoff,
    pvalueCutoff  = pvalueCutoff
  )

  if (is.null(enrich_res) || nrow(enrich_res@result) == 0L) {
    return(enrich_res)
  }

  df <- enrich_res@result

  # drop the dummy term from results
  df <- df %>% dplyr::filter(ID != dummy_id)

  # keep original ratios for reference
  df$GeneRatio_orig <- df$GeneRatio
  df$BgRatio_orig   <- df$BgRatio

  # now recompute ratios using exactly:
  #   - denominator for GeneRatio = number of selected genes in universe
  #   - denominator for BgRatio   = number of background genes
  n_sel_total <- length(genes_sel_used)
  n_bg_total  <- length(universe_for_test)

  df$GeneRatio_fixed <- paste0(df$Count,   "/", n_sel_total)
  df$BgRatio_fixed   <- paste0(df$setSize, "/", n_bg_total)

  enrich_res@result <- df
  enrich_res
}
```

Among all the genes highlighted by FASH:

```{r}
result <- enrich_set(genes_selected = genes_highlighted2, background_gene = all_genes)
result@result %>% 
  filter(pvalue < 0.05) %>%
  dplyr::select(GeneRatio, BgRatio, pvalue, qvalue)
```

Among the genes highlighted by FASH that are classified as having middle dynamic eQTLs:

```{r}
result <- enrich_set(genes_selected = middle_genes, background_gene = all_genes)
result@result %>% 
  filter(pvalue < 0.05) %>%
  dplyr::select(GeneRatio, BgRatio, pvalue, qvalue)
```

Among the genes highlighted by FASH that are classified as having late dynamic eQTLs:

```{r}
result <- enrich_set(genes_selected = late_genes, background_gene = all_genes)
result@result %>% 
  filter(pvalue < 0.05) %>%
  dplyr::select(GeneRatio, BgRatio, pvalue, qvalue)
```


